#!/usr/bin/env Rscript


library(argparse)

usage <- function() {
  usage.text <- '\nUsage: script.R --coverage_files <full path to genome coverage files in BED format> --metadata <path to the metadata file having the columns: Ct and sample_name> --prefix <prefix to the output filename> --outdir <path to the output directory name>\n\n'
  return(usage.text)
}

parser <- ArgumentParser()
parser$add_argument("--coverage_files", nargs="+", default=NULL, help="full path to the genome coverage files in BED format (generated by bedtools genomecov")
parser$add_argument("--prefix", default="allsamples", help="prefix to the output filename")
parser$add_argument("--outdir", default="./", help="output directory path")
args <- parser$parse_args()

###########################################
#######        load packages        #######
###########################################

library(ggplot2)
library(ggforce)
library(hrbrthemes)
library(scales)
library(viridis)
library(reshape2)
library(dplyr)
library(cowplot)
library(ComplexHeatmap)

###########################################
#######           checks           #######
###########################################

input_files <- unique(unlist(strsplit(args$coverage_files," ")))
if (length(input_files) == 0) {
  parser$print_help()
  stop("At least one input file must be supplied", call.=FALSE)
}
if (!all(file.exists(input_files))) {
  parser$print_help()
  stop(paste("The following input files don't exist:", 
             paste(input_files[!file.exists(input_files)], 
                   sep='', collapse=' '), sep=' '), call.=FALSE)
}

outdir <- args$outdir
if (tail(strsplit(outdir,"")[[1]],1)!="/") {
  outdir <- paste(outdir,"/",sep='')
}
if (!file.exists(outdir)) {
  dir.create(outdir, recursive=TRUE)
}

prefix <- args$prefix

###########################################
#######      read input files       #######
###########################################

coverage_list <- list()
for (i in 1:length(input_files)){
  fn = input_files[i]
  sample_name <- strsplit(basename(fn), ".", fixed=T)[[1]][1]
  dat <- read.table(fn, stringsAsFactors = F, header=T)
  dat$sample_name <- sample_name
  
  pos.df <- dat %>% dplyr::select(start, end, amplicon_id)
  pos.df$pos <- c(paste(pos.df$start, pos.df$end, sep = "-"))
  pos.df <- pos.df %>% dplyr::select(amplicon_id, pos)
  
  dat <- dat %>% dplyr::select(amplicon_id, sample_name, mean_depth)
  coverage_list[[i]] <- dat
}
data <- do.call(rbind, coverage_list)


# reshape the data into wide format
cov.df <- reshape(data, idvar = "sample_name", timevar = "amplicon_id", direction = "wide")
names(cov.df) <- gsub("mean_depth.", "", names(cov.df))
names(cov.df) <- gsub("rvfv.", "", names(cov.df))
names(cov.df) <-gsub(".400", "", names(cov.df))
cov.df <- data.frame(cov.df, row.names = 1)
cov.df <- log2(cov.df + 1)

mat <- as.matrix(cov.df)
rownames(pos.df) <- colnames(mat)

cols <- colorRampPalette(c('#377EB8', 'white', '#E41A1C'))(3)
.coverage = anno_density(mat, type = "line", gp = gpar(col = "#D55E00"))
ha_mix_top = HeatmapAnnotation(coverage = .coverage, height = unit(2, "cm"))

# graphics to display the distribution of rows
.coverage = anno_density(mat, type = "violin", gp = gpar(fill = "#377EB8"), 
                       which = "row")

ha_mix_right = HeatmapAnnotation(coverage = .coverage, which = "row", 
                                 width = unit(3, "cm"))



if (dim(mat)[1] < 4) {
  height = 0.1969*nrow(mat) + (2*1.5)
  width = 0.1969*ncol(mat) + (2*1.5)
} else {
  height = 0.1969*nrow(mat) + (2*1.5)
  width = 0.1969*ncol(mat) + (2*1.5)
}

pdf(file=paste(outdir, prefix, ".amplicon.mean.coverage.heatmap.pdf", sep = ""), width = width, height = height)
# combine annotation with heatmap
Heatmap(mat, 
        col = viridis(50),
        # column_title = "Heatmap to show mean amplicon coverage across samples",
        cluster_rows = TRUE,
        cluster_columns = FALSE,
        show_row_names = TRUE,
        show_column_names = TRUE,
        column_title_side = "top",
        row_names_side = 'left',
        rect_gp = gpar(col="white", lwd=1),
        heatmap_legend_param = list(title_gp=gpar(fontsize=10, fontface="bold"), labels_gp=gpar(fontsize=10), direction="vertical"),
        row_names_gp = gpar(fontsize = 9),
        column_names_gp = gpar(fontsize = 9),
        column_order = colnames(mat),
        name = 'log2(coverage+1)',
        # height = unit(5, "mm")*nrow(mat),
        # width = unit(5, "mm")*ncol(mat)
        ) + 
  ha_mix_right
# top_annotation = ha_mix_top
dev.off()